# 애그리거트

## 애그리거트 개념

백 개 이상의 테이블을 한 장의 ERD 에 모두 표시하려면 개별 관계를 파악하느라, 큰 틀에서 데이터 구조를 이해하는 데 어려움을 겪게 된다.
이와 비슷하게 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고, 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.

이렇게 복잡한 도메인을 이해하고 관리하기 쉬운 `단위`로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 애그리거트이다. 
> 즉, 애그리거트는 관련된 객체를 하나로 묶은 군집이다.

애그리거트 단위로 도메인들을 나누고, 그 단위로 일관성을 관리하면 그 만큼 복잡도가 낮아지게되고 도메인을 확장하고 변경하는데 소요되는 비용도 줄어든다.

애그리거트의 경계를 설정할 떄 기본이 되는 것은 도메인의 규칙과 요구사항이다. 

- 도메인 규칙에 따라 `함께 생성되는` 구성요소는 한 애그리거트에 속할 가능성이 높다.
- 사용자 요구사항에 따라 `함께 변경되는` 빈도가 높은 객체들은 한 애그리거트에 속할 가능성이 높다.

주의할 점은 `A 가 B 를 갖는다` 의 관계를 보고 한 애그리거트로 묶어서 생각하기 쉬운데, 이 관계가 반드시 한 애그리거트에 속하는 것은 아니다.
예를 들어 상품과 리뷰는 상품이 리뷰를 갖는 관계이지만, 둘은 함께 생성되지도 않고 또 함께 변경되지도 않는다. 게다가 둘의 주체도 각각 상품 담당자와 소비자로 다르다. 
따라서 상품과 리뷰는 서로 다른 애그리거트로 볼 수 있다.

처음 도메인 모델을 만들 때, 많은 도메인들을 하나의 애그리거트로 보이는 경우가 많은데 이는 경험이 부족한 것으로 도메인 규칙과 요구사항을 더 깊이 파악하고 이해할수록 실제 애그리거트의 크기는 줄어든다.
> 보통 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많으며 두 개 이상의 엔티티로 구성되는 애그리거트는 흔치 않다.

## 애그리거트 루트

애그리거트는 여러 객체로 구성되기 때문에 `도메인 규칙`을 지키기 위해서는 `애그리거트에 속한 모든 객체가 정상 상태`를 지녀야한다. 
이를 위해 애그리거트 전체를 관리할 책임을 지니는 대표 엔티티, 루트 애그리거트가 필요하다.

이 루트 애그리거트의 핵심 역할은 `애그리거트의 일관성`을 유지하는 것이다. 예를 들어 주문 애그리거트가 배송지 변경, 상품 변경과 같은 기능을 제공한다고 하면 
루트 애그리거트는 해당 기능을 구현한 메서드를 제공해야한다. 그리고 이 루트 애그리거트 외에서는 애그리거트의 일관성을 깨뜨릴 수 없도록 강제 해야한다.

```java

class Order {
    private String name;
}

Order order = new Order();
order.setName("주문명");

```

즉, 위와 같은 식으로 주문 객체의 이름을 변경할 때, 직접 변경하는 것은 허용되지 않는다. 
이는 업무 규칙을 무시하고 직접 DB 테이블의 데이터를 수정하는 것과 같은 결과를 만든다.

```java

class Order {
    private String name;
}

Order order = new Order();
if(업무 규칙) {
    order.setName("주문명");
}
```

더불어 업무 규칙을 지키기 위해 다음과 같이 상태 확인 로직을 `응용 서비스`에 구현하는 것 또한 여러 곳에 
검증을 위한 `중복 로직`을 구현할 가능성이 있기 때문에 유지보수에 도움이 되지 않는다.

```java

class Order{
    private final String name;
    
    public void setName(String name) {
        if(업무 규칙()) {
            this.name = name;
        }
    }
    
    private boolean 업무 규칙() {
        return 규칙 검증 결과;
    }
    
}

```

- 단순히 필드를 변경하는 set 메서드를 public 범위로 만들지 않는다.
- 값 타입은 불변으로 구현한다.

위와 같이 외부에서 내부 상태를 함부로 바꾸지 못하도록 값 타입을 불변으로 설계하면 애그리거트의 일관성이 깨질 가능성도 줄어든다.
즉, 벨류 객체를 불변으로 설계하여 값을 변경하는 방법을 새로운 값을 할당하는 방법으로 제한하면 밸류 타입의 내부 상태를 변경하기 위한 수단이 애그리거트 루트로 제한되므로 
애그리거트 전체의 일관성을 올바르게 유지할 수 있다.

### 애그리거트 루트의 기능 구현

(정리 필요)

### 트랜잭션 범위

(정리 필요)