# 동작 파라미터화 코드 전달하기

## 이론 개요

### 1. 추상적 조건으로 필터링하기 : 유연하고 동적인 함수 설계

함수에 대해 시시각각 변화하는 사용자의 요구사항에 대해 유연하게 반응하도록 구현해야할 필요가 있을 때, 동작 파라미터를 활용할 수 있다.
> 동작 파라미터는 어떻게 실행될지 결정되지 않은 코드 블록을 의미한다. 

예를 들어 사과를 고르는 목적을 가지는 함수가 존재할 때, 필터링 조건은 여러 개가 될 수 있다. 
- 녹색 사과만 담는다.
- 500 그램 이상의 사과만 담는다.
- 한국산 사과만 담는다.

가장 간단하게 생각해보면 두 개의 방법이 있다.

첫번째 방법은 A, B, C 의 역할을 하는 함수를 각각 구현하는 방법이다. 하지만 비슷한 기능을 하는 함수를 N 개 이상 
구현하는 것은 보일러플레이트 코드 중복 코드를 양산할 수 있으며, 이는 유지보수성을 떨어뜨린다.

두번째 방법은 A, B, C 의 역할을 하나의 함수에서 동시에 수행하도록 하는 방법이다. 첫번째 방법에 비해 중복 코드는 줄어들 수 있으나, 
가독성이 심하게 떨어질 수 있으며 이 또한 좋은 방법이 아니다.

가장 좋은 방법은 `필터링 조건을 추상적으로 설정하여 요구사항 변화에 능동적으로 대처`할 수 있도록 하는 것이다. 즉, 함수는
고정적이지만 파라미터를 동적으로 확장할 수 있도록 설계하는 것으로 이렇게 하면 `보일러 플레이트 코드를 발생시키지 않으면서도 동시에 
요구사항 변화에도 유연하게 대처`할 수 있는 함수를 만들 수 있다. 

코드로 설명하자면 함수(메서드) 파라미터를 추상화하고, `Predicate` 를 추상화한 구현 클래스를 N 개 정의한다. 각각의 클래스들은 고유의 전략을 캡슐화하고
캡슐화된 전략은 각 클래스가 인스턴스화 되어 런타임에 함수에서 전달 될 수 있도록 한다. `Predicate` 는 함수 내에서 조건에 따라 실행된다. 

### 2. 익명 클래스의 활용 : 불필요한 코드 줄이기

위와 같이 동적인 파라미터를 사용하여 유연한 함수를 만들었지만, 이를 사용하는 입장에서 생각해보면 불편한 점이 있다.

바로 N 개의 전략이 필요하면 N 개의 클래스를 생성해야하고, N 번의 인스턴스화가 필요하다는 것이다. 이렇게 되면 
클래스 선언 및 인스턴스화를 위한 쓸데없는 코드의 양이 들어나게 된다. 특히 재활용이 필요없는 클래스의 경우 비용에 비해 그 활용도가 매우 떨어지게된다.

별도의 클래스를 선언하지 않으면서 인스턴스화를 할 수 있는 방법은 JAVA 에서 제공하고 있다. `익명 클래스`를 활용하면 된다. 

### 3. 람다 표현식의 활용 : 장황한 코드 줄이기

익명 클래스를 활용하면 쓸데 없는 코드의 양이 줄어 사용하는 입장에서의 편의성을 증대시킬 수 있다. 하지만 익명 클래스 자체가 많이 사용되지 않는다.
코드의 양이 드라마틱하게 줄어드는 것도 아니고, 특히 지역 클래스와 비슷한 익명 클래스를 사용하는 순간 this 같은 키워드가 포함될 때 골치가 아파질 수 있다.

JAVA 8 버전 부터 지원해주는 `람다 표현식`을 사용하여 코드 복잡도를 줄이지 않을 이유가 없다.

### 4. 리스트 형식으로 추상화 

N 개의 전략을 활용하여 필터링 할 수 있는 함수를 만들었다. 만약 이 함수가 실행될 대상이 사과에 한정되지 않도록 하려면 어떻게 해야할까?

방법은 `형식 파라미터 T 를 활용하여 여러 타입을 받을 수 있도록 함수의 파라미터를 리스트 형식으로 추상화`해버리면 된다.

이 또한 JAVA 8 에서 지원하는 기능이 있기에 가능한 일이다.

### 정리

> 책의 내용을 간단히 정리하자면 위와 같으며, 아래의 자바 문법과 기능 정도는 알아야 사용할 수 있다.

- 람다 표현식
- 제네릭