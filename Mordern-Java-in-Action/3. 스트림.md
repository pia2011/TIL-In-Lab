# 스트림

스트림은 자바 언어 설계자들의 다음과 같은 고민에 대한 해결방법으로 등장했다.

- SQL 에서 질의를 통해 따로 구현을 명시하지 않고도 원하는 값을 구할 수 있는 기능을 제공하는 것 처럼, 컬렉션에서도 이와 비슷한 기능을 만들 수 있지 않을까?
- 많은 요소를 포함하고 있는 커다락 컬렉션에서 멀티코어 아키텍처를 이용하여 병렬로 연산을 처리하여 값을 가져오고 싶을 때, 간단하게 구현할 수 있는 방법이 있지 않을까?

## 1. 스트림이란 

자바8 API 에서 새롭게 등장한 기능으로 데이터를 처리할 때, 구현 코드 대신 질의를 통해서 컬렉션의 데이터를 처리하고자 등장했다.
또한 스트림을 활용하면 복잡한 멀티스레드 코드를 구현하지 않아도, 컬렉션 데이터를 투명하게 병렬로 처리가 가능하다.

```java
    @Test
    void 스트림_예시() {

    List<String> lowCaloricDishesName = dishes.stream()
        .filter(dish -> dish.getCalories() < 400)
        .sorted(comparing(Dish::getCalories))
        .map(Dish::getName)
        .collect(Collectors.toList());
    }
    
    @Test
    void 병렬_스트림_예시() {

    List<String> lowCaloricDishesName = dishes.parallelStream()
        .filter(dish -> dish.getCalories() < 400)
        .sorted(comparing(Dish::getCalories))
        .map(Dish::getName)
        .collect(Collectors.toList());
    }
```

또한 선언형으로 코드를 구현할 수 있다는 것도 장점 중 하나이다. 예를 들어 `저칼로리 음식만 선택하라` 라는 기능을 구현하기 위해서
기존 자바 7 까지는 반복문, 제어문과 같은 제어 블록을 사용하여 어떻게 구현해야할지를 지정해주어야 했다면, 스트림을 통해서는
따로 지정해줄 필요 없이 `저칼로리 음식만``선택해라` 라는 질의만 주면 기능을 수행할 수 있다.

여기에 더불어 동작 파라미터화를 활용하면 보다 유연하게 요구사항에 대응할 수 있게된다. 스트림에는 
filter, sorted, map, collect 와 같은 여러가지 `빌딩 블록 연산`을 연결하여 복잡한 데이터 처리 파이프라인도 
구성할 수 있으며 이렇게 복잡한 데이터 처리 파이프라인을 구현하더라도 제어 블록을 남발하는 것보다 훨씬 가독성과 명확성에서
유리하다.

앞서 언급했던 `고수준 빌딩 블록`으로 이루어져 있는 빌딩 블록 연산(filter, map, sorted, collect)들은 특정
스레드 모델에 제한되지 않고 어디서든 자유롭게 사용할 수 있으며, 데이터 처리 과정을 `병렬화`하면 스레드와 락 걱정 없이
구현할 수 있다.

위와 같은 내용을 기반으로 스트림의 특징과 장점을 다음과 같이 요약하기도 한다.

- 선언형 : 가독성 UP
- 조립형 : 유연성 UP
- 병렬화 : 성능 UP

스트림의 정의는 다음과 같이 정의할 수 있다. `데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소`

위 정의에 대해 하나씩 살펴보면 다음과 같이 분리가 가능하다.

#### 1. 연속된 요소
스트림은 컬렉션과 마찬가지로 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.

#### 2. 소스
스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 `소스` 로 부터 데이터를 소비한다. 특히 컬렉션이 소스인 경우
해당 컬렉션에서 정렬된 순서를 그대로 유지한다.

#### 3. 데이터 처리 연산
스트림은 `함수형 프로그래밍 언어에서 일반적으로 지원하는 연산`과 `DB 와 비슷한 연산` 을 지원한다.

또 스트림의 중요한 특징 두 가지를 더 알아보면 다음과 같다.

- 파이프라이닝(Pipelining) : 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환한다.
- 내부 반복 : 반복자를 이용하여 명시적으로 반복하는 컬렉션과 다르게 스트림은 내부 반복을 지원한다.


```java
    @Test
    void 스트림_처리_연산() {

    List<String> threeHighCaloricDishNames = dishes.stream()
        .filter(dish -> dish.getCalories() > 300)
        .sorted(comparing(Dish::getCalories).reversed())
        .map(Dish::getName)
        .limit(3)
        .collect(Collectors.toList());

        System.out.println(threeHighCaloricDishNames);
    }

```

다음은 위에서 설명했던 내용을 기반으로 위 스트림이 사용된 코드를 해석해보자면, 다음과 같다.

- 데이터 소스 : 요리 리스트
- 연속된 요소 : 바나나, 딸기, 사과, 포도 
- 데이터 처리 연산 : filter, map, sorted, limit, collect  (연산자)
- 파이프라이닝 : filter, map, sorted, limit (Stream 을 반환하는 연산자)

> collect 연산으로 파이프연산을 최종 처리해서 결과를 반환한다. 즉, collect 가 호출되기 전까지 파이프라이닝을 형성하며 메서드 호출이 저장되는 효과가 있다.
> collect 가 호출되기 전까지는 파이프라이닝을 형성할 뿐 어떤 요소도 선택되지 않으며 당연히 출력 결과도 없다.

다시 각각의 연산자의 역할 대해서 살펴보면 다음과 같다.

- filter : 람다를 인수로 받아 스트림에서 특정 요소를 제외시킨다.
- map : 람다를 이용해서 한 요소를 다른 요소로 변환하거나 정보를 추출한다.
- limit : 정해진 개수 이상의 요소가 스트림에 저장되지 못하게 스트림의 크기를 축소(truncate) 한다.
- collect : 스트림을 다른 형식으로 변환한다.

## 2. 스트림과 컬렉션

자바의 기존 컬렉션과 새로운 스트림 모두 `연속된` 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다. 
하지만 데이터를 어느 시점에 계산 하는가에 대해서는 차이점을 갖는다. 

컬렉션은 현재 자료구조가 포함하는 `모든 값을 메모리에 저장`하는 자료구조이며 그렇기에 모든 요소는 컬렉션에 추가되기전에 `미리 계산이 되어 저장되어야 한다`.

이에 반해 스트림은 이론적으로 요청할 때에만 요소를 계산하는 고정된 자료구조이다. 
이는 컬렉션과 달리 스트림에는 요소를 추가하거나 스트림에서 요소를 제거할 수 없다는 것을 의미한다. 이런 스트림의 특징은 프로그래밍에 굉장한 도움을 준다.

핵심은 스트림이 사용자가 요청하는 값만을 추출해낸다는 것이고 결과적으로 스트림은 생산자와 소비자의 관계를 형성한다. 
> 스트림은 게으르게 만들어지는 (게으른 생성) 컬렉션과 같다.  사용자가 데이터를 요청할 때에만 값을 계산한다.  

간단한 예시를 들면 Stream 은 `인터넷 스트리밍`과 같이 필요할 때 값을 계산하지만, Collection 은 `DVD`와 같이 필요한 모든 값을 계산할 때까지 기다린다.

### 스트림은 단 한번만 탐색할 수 있다

스트림은 딱 한번만 탐색할 수 있으며, 탐색된 스트림의 요소는 `소비` 된다. 즉, 반복자와 마찬가지로 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서
새로운 스트림을 만들어야한다. 

### 외부 반복과 내부 반복

컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야하며 이를 `외부 반복`이라고 한다.

```java
// 사용자가 직접 요소를 반복해야하고, 반복자가 필요하다.
List<Dish> todayMenus = new ArrayList<>();
for (Dish dish: dishes) { // `명시적`으로 순차 반복
   todayMenus.add(dish); // 추출해서 리스트에 추가
}
```

반면 스트림 라이브러리는 `내부 반복`을 사용한다. 함수에 어떤 작업을 수행하지만 지정하면 모든것이 알아서 처리된다.
파이프라인을 실행할 뿐, 컬렉션과 다르게 별도의 반복자가 필요하지 않다.

```java
List<Dish> todayMenus = dishes.stream().toList();
```

